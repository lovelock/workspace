IO的并发
1.协程
fezzik和vizzini都带有协程，它们是彼此无关的Object实例。
这里异步触发talk和rhyme方法，它们并发执行，用yield消息在指定时间段自动把控制权交给另一方法。最后一行的pause用来等待所有异步消息执行完毕，然后推出程序。协程在面对需要多任务合作的解决方案时表现完美。

利用协程，应用程序可以在适当的时间放弃控制权。比如分布式客户端可以在等待服务端响应时放弃控制权，工作者进程可以在处理完队列中的产品后暂停。

2.actor
在test.io的例子中，当最后执行的两个start没有加@@时，两个程序会按顺序执行，因为一定是第一个消息结束之后，第二个消息才会开始。但可以加上@@，让对象在自己的线程中运行。
在最后加了wait(3)，一遍让所有的线程在程序终止前执行完毕。这样做就能获得非常棒的结果。
同时运行了两个线程，只不过发送了异步消息给这两个对象，它们就变成了actor.

3.future
future是在异步调用消息时立即返回的一个对象。由于被调用的消息可能需要一段时间处理，因此到最终产生结果的时候，future会变成这个结果值。如果在结果尚未产生时请求future值，进程会阻塞直到产生结果为止。



