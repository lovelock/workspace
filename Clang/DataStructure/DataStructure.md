#### 数据

数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别、并**输入**给计算机**处理**的符号集合。
数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。
数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。但实际上数据元素才是数据模型的着眼点。
数据对象：是性质相同的数据元素的集合，是数据的子集。
在不产生混淆的前提下，将数据对象简称数据。
不同数据元素之间不是独立的，而是存在特定的关系，这些关系称为结构。
数据结构是相互之间存在一种或多种特定关系的数据元素的集合。
逻辑结构是数据对象中数据元素之间的相互关系。
物理结构是数据的逻辑结构在计算机中的存储形式。
集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。
线性结构中的元素是一对一的关系。
树形结构中的数据元素之间存在一对多的层次关系。
图形结构的数据元素是多对多的关系。
数据元素的存储结构：顺序存储和链式存储。
顺序存储是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。（例如数组）
链式存储结构是把数据存放在任意的存储单元里，这组存储单元可以是连续的也可以是不连续的。（由于数据元素的存储关系并不能反映其逻辑关系，因此需要用指针存放数据元素的地址）
数据类型是一组性质相同的值的集合及定义在此集合上的一些操作的总称。
数据类型分为两类：
原子类型：不可再分解的基本类型，包括整型、实型、字符型等。
结构类型：由若干个类型组合而成，可以再分解。
抽象是指抽取出事物具有的普遍性的本质。
抽象数据类型是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特定，而与其在计算机内部如何表示和实现无关。
抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。
```
ADT	抽象数据类型名
Data
数据元素之间逻辑关系的定义
Operation
	
	操作1
	初始条件
	操作结果描述
	
	操作2
	....
endADT
```
#### 算法
算法是解决特定问题或求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。
算法的特性：有穷性、确定性、可行性、输入、输出
算法的设计要求：正确性、可读性、健壮性、高效率和低存储量需求。

##### 时间复杂度
算法在计算机上运行所消耗的时间取决于下列因素：
1. 算法所采用的策略、方法。
2. 编译产生的代码质量。
3. 问题的输入规模。
4. 机器执行指令的速度。
函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。
最高次项的指数越大，函数随着n的增长，结果也会变得增长特别快。因此，判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项的阶数。
根据算法的时间复杂度来估算算法时间效率。
时间复杂度定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n) = O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为“时间复杂度”。其中f(n)是问题规模n的某个函数。
推导大O阶的方法：
1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，则去除于这个项相乘的常数。
得到的结果就是大O阶。
分析算法的复杂度，关键就是要分析循环结构的运行情况。
循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。
最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常除非特别指定，我们提到的运行时间都是在最坏情况的运行时间。
平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。

##### 空间复杂度
算法的空间复杂度通常计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中n为问题的规模，f(n)为语句关于n所占存储空间的函数。

#### 线性表
线性表是零个或多个数据元素的有限序列。
线性表元素的个数n(n>=0)定义为线性表的长度，当n=0时，称为空表。
在较复杂的线性表中，一个数据元素可以由若干个数据项组成。
线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。
线性表的三个属性：存储空间的起始位置、最大存储容量、当前长度。
数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般不变的。高级语言用编程手段实现动态分配数组，但会带来性能上的损失。
线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。在任意时刻，线性表的长度应该小于等于数组的长度。
存储器中的每个存储单元都有自己的编号，这个编号称为地址。
存取时间性能为O(1)的结构称为随机存取结构。
###### 线性表的线性存储结构
插入算法的思路：
1. 如果插入位置不合理，抛出异常。
2. 如果线性表长度大于数组长度，则抛出异常或动态增加容量。
3. 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置。
4. 将要插入元素填入位置i处。
5. 表长加1。
删除算法的思路：
1. 如果删除位置不合理，抛出异常。
2. 取出删除元素。
3. 从删除元素位置开始遍历到最后一个元素位置，分别将它们向前移动一个位置。
4. 表长减1。

线性表的顺序存储结构，在存、读数据时，不管是在哪个位置，时间复杂度都是O(1)；而插入或删除时，时间复杂度都是O(n)。这就说明，它比较适合元素个数不太变化，而更多是存取数据的应用。

线性表顺序存储结构优点：
1. 无须为表示表中元素之间的逻辑关系而增加额外的存储空间。
2. 可以快速的存取表中任意位置的元素。

线性表顺序存储结构缺点：
1. 插入和删除操作需要大量移动元素。
2. 当线性表长度变化较大时，难以确定存储空间的容量。
3. 造成存储空间的碎片。

##### 线性表的链式存储结构
头指针与头结点的异同：
1. 头指针
    - 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。
    - 头指针具有标识作用，所以常用头指针冠以链表的名字。
    - 无论链表是否为空，头指针均不为空。头指针是链表的必要元素。
2. 头结点
    - 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）。
    - 有了头结点，对在第一元素结点前插入和删除第一结点，其操作域其他结点的操作就统一了。
    - 头结点不一定是链表的必须要素。

p是指向线性表的第i个元素，则该结点ai的数据域可以用p->data来表示，即p->data=ai，而ai的指针域可以用p->next来表示，p->next->data=a(i+1)。

获得链表第i个数据的算法思路：
1. 声明一个结点p指向链表的第一个结点，初始化j从1开始。
2. 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1。
3. 若到链表末尾p为空，则说明第i个元素不存在。
4. 否则查找成功，返回结点p的数据。

单链表第i个数据插入结点的算法思路：
1. 声明一结点p指向链表第一个结点，初始化j从1开始。
2. 当j &lt; i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1。
3. 如果链表末尾p为空，则说明第i个元素不存在。
4. 否则查找成功，在系统中生成一个空结点s。
5. 将数据元素e赋值给s->data。
6. 单链表的插入标准语句s->next = p->next; p->next = s;
7. 返回成功。

单链表第i个数据删除结点的算法思路：
1. 声明一个结点p指向链表的第一个结点，初始化j从1开始。
2. 当j &lt; i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1。
3. 若到链表末尾p为空，则说明第i个元素不存在。
4. 否则查找成功，将欲删除的结点p->next赋值给q。
5. 单链表删除标准语句：p->next = q->next 
6. 将q结点中的数据赋值给e，作为返回。
7. 释放q结点。
8. 返回成功。

单链表整表创建的算法思路：
1. 声明一结点p和计数器变量i。
2. 初始化一空链表L。
3. 让L的头结点的指针指向NULL，即建立一个带头结点的单链表。
4. 循环。
    - 生成一新结点赋值给p;
    - 随机生成一数字赋值给p的数据域p->data;
    - 将p插入到头结点欲新一结点之间。

单链表删除的算法思路：
1. 声明一结点p和q。
2. 将第一个结点赋值给p。
3. 循环：
    - 将下一结点赋值给q；
    - 释放p;
    - 将q赋值给p。

单链表结构和顺序存储结构的对比：
###### 存储分配方式
1. 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
2. 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素。

###### 时间性能
1. 查找
    - 顺序存储结构O(1)
    - 单链表(n)
2. 插入和删除
    - 顺序存储结构需要平均移动表长一半的元素，时间为O(n)
    - 单链表在删除某位置的指针后，插入和删除时间仅为O(1)

###### 空间性能
1. 顺序存储结构需要预分配存储空间，分大了浪费，分小了容易发生上溢。
2. 单链表不许空分配存储空间，只要有就可以分配，元素个数不受限制。

#### 静态链表
用数组描述的链表叫做静态链表。
未被使用的元素叫做“备用链表”。数组的第一个元素，即下标为0的元素的cur存放备用链别的第一个节点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中头节点的作用。

静态链表的优点：
1. 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。
2. 没有解决连续存储分配带来的表长难以确定的问题。
3. 失去了顺序存储结构随机存取的特性。

将单链表中终端结点的指针端由空指针改为指向头指结点，就使整个单链表形成一个环，这种头尾相接的单链表称为循环单链表，简称循环链表（Circular Linked List）。
双向链表（double linked list）是在单项链表的每个结点中，再设置一个指向其前驱结点的指针域。


栈和队列
栈是限定仅在表尾进行插入和删除操作的线性表。
允许插入和删除的一段称为栈顶（top），另一端称为栈底（bottom），不包含任何数据元素的栈称为空栈。栈又称先进先出的线性表。简称LIFO结构。Last In, First Out.
栈的插入操作，叫做**进栈**，也称**压栈**、**入栈**。
栈的删除操作，叫做**出栈**，也称**弹栈**。
##### 栈的抽象数据类型

队列是限定仅在一段进行插入操作，在另一端进行删除操作的线性表。

栈的链式存储结构——链栈。
如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好使用链栈，反之，如果它的变在可控范围内，建议使用顺序栈会更好一些。
在高级语言中，调用自己和调用其他的函数并没有本质的区别。我们把一个直接调用自己或者通过一系列的调用语句间接的调用自己的函数叫做递归函数。
每个递归定义必须至少有一个条件，满足当递归不再进行，即不再引用自身而是返回值退出。
迭代和递归的区别：迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。所以应该视

#### 串
串（string）是由零个或多个字符组成的有限序列，也叫字符串。
不太理解那个O(n+m)的复杂度是怎么计算的
前后缀一个字符相等，k值是2，两个字符相等，k值是3,n个相等，k值就是n+1。
